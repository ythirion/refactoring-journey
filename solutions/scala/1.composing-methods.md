# 1. Composing Methods
## [Extract method](https://ythirion.github.io/refactoring-journey/journey/1-composing-method.html#extract-method)
Shortcut : ⌘+⌥+M or Ctrl+Alt+M

### Practice 1

- Open `OrderService` in `composing.methods` package

* Identify Code smells

```scala
object OrderService {

  def generateStatement(order: Order): Try[String] = {
    // Comments in the method often indicates that methods are doing too many stuff
    if (order.customer.name.nonEmpty && order.products.nonEmpty) {
      //Add banner
      val statement: String = s"Statement for : ${order.customer}$lineSeparator"
      // Add details
      val statementWithProduct: String =
        order.products.foldLeft(statement)((acc, p) => acc + s"Product: ${p.name} Price: ${p.price}$lineSeparator")
      // Add total
      val total: Double = AmountCalculator.calculatePrice(
        order,
        applyAgeDiscount = true,
        order.customer.age
      )
      val statementWithProductAndTotal: String =
        statementWithProduct + "Total: " + total + "€"

      Success(statementWithProductAndTotal)
    } else Failure(new IllegalArgumentException("InvalidOrder"))
  }
}
```

* Invert the guards and isolate it in a function
  * Launch the tests

```scala
// => T : Pour avoir le bon ordre d'execution
private def checkState[T](order: Order)(dataIfSuccess: => T): Try[T] = {
  if (order.customer.name.isEmpty || order.products.isEmpty) {
    Failure(new IllegalArgumentException("InvalidOrder"))
  } else
    Success(dataIfSuccess)
}
```

* Extract each lines behind comments in a dedicated method

```scala
private def createStatement(customer: Customer): String =
  s"Statement for : $customer$lineSeparator"


private def formatProducts(order: Order): String =
  order.products
        .map(p => s"Product: ${p.name} Price: ${p.price}")
        .mkString(lineSeparator)

private def formatTotal(total: Double): String = s"Total: ${total}€"
```

* Putting all together

```scala
private def printStatement(order: Order, total: Double): String = {
  s"${createStatement(order.customer)}${formatProducts(order)}$lineSeparator${formatTotal(total)}"
}
```

* And the function that combine the check state function and print one

```scala
  def generateStatement(order: Order): Try[String] = {
    checkState(order) {
      printStatement(order, getTotal(order))
    }
  }

  def getTotal(order: Order): Double = {
    AmountCalculator.calculatePrice(
      order,
      applyAgeDiscount = true,
      order.customer.age
    )
  }
```

### Practice 2

- Open `AmountCalculator` in `composing.methods` package

* Identify code smells

```scala
object AmountCalculator {
  def calculatePrice(amount: Double, age: Int): Double = {
    // Duplicated code
    // Mutations
    var discountBasedOnAge = .0
    if (age <= 16) discountBasedOnAge = 0.35 * amount
    else if (age >= 60) discountBasedOnAge = 0.2 * amount

    amount - discountBasedOnAge
  }

  def calculatePrice(
      order: Order,
      applyAgeDiscount: Boolean,
      age: Int
  ): Double = {
    var result = .0
    var discount = .0
    var resultWithDiscount = .0
    for (product <- order.products) {
      result += product.price
    }
    if (applyAgeDiscount) {
      // Duplicated code
      // Mutations
      var discountBasedOnAge = 0d

      if (age <= 16) discountBasedOnAge = 0.35 * result
      else if (age >= 60) discountBasedOnAge = 0.2 * result

      discount = discountBasedOnAge
    }
    resultWithDiscount = result - discount
    resultWithDiscount
  }
}
```

* Start by extracting a `calculateDiscountBasedOnAge` method
  * Unfortunately with scala Intellij does not detect code duplication
  * So do not propose to replace duplicated code with the new method call...

```scala
private def calculateDiscountBasedOnAge(amount: Double,
                                        age: Int): Double = {
  var discountBasedOnAge = .0
  if (age <= 16) discountBasedOnAge = 0.35 * amount
  else if (age >= 60) discountBasedOnAge = 0.2 * amount
  discountBasedOnAge
}
```

* Plug the call to this method

```scala
def calculatePrice(amount: Double, age: Int): Double = {
  val discountBasedOnAge: Double = calculateDiscountBasedOnAge(amount, age)
  amount - discountBasedOnAge
}

def calculatePrice(order: Order,
                   applyAgeDiscount: Boolean,
                   age: Int): Double = {
  var result = .0
  var discount = .0
  var resultWithDiscount = .0
  for (product <- order.products) {
    result += product.price
  }
  if (applyAgeDiscount) {
    discount = calculateDiscountBasedOnAge(result, age)
  }
  resultWithDiscount = result - discount
  resultWithDiscount
}
```

* Clean `calculateDiscountBasedOnAge`
  * var is hell
  * Define constants for magic numbers

```scala
private val YoungMaximumAge = 16
private val YoungDiscount = 0.35
private val OldMinimumAge = 60
private val OldDiscount = 0.2

private def calculateDiscountBasedOnAge(amount: Double, age: Int): Double = {
  age match {
    case young if young <= YoungMaximumAge => YoungDiscount * amount
    case old if old >= OldMinimumAge       => OldDiscount * amount
    case _                                 => 0
  }
}
```

* Clean code :

```scala
def calculatePrice(order: Order,
                   applyAgeDiscount: Boolean,
                   age: Int): Double = {
  val amount = order.totalPrice
  val discount = if (applyAgeDiscount) calculateDiscountBasedOnAge(amount, age) else 0

  amount - discount
}
```

* Factorize by creating new private method with default parameter

```scala
object AmountCalculator {
  private val YoungMaximumAge = 16
  private val YoungDiscount = 0.35
  private val OldMinimumAge = 60
  private val OldDiscount = 0.2

  def calculatePrice(amount: Double, age: Int): Double = {
    calculate(amount, age)
  }

  def calculatePrice(
      order: Order,
      applyAgeDiscount: Boolean,
      age: Int
  ): Double = {
    calculate(order.totalPrice, age, applyAgeDiscount)
  }

  private def calculate(
      amount: Double,
      age: Int,
      applyAgeDiscount: Boolean = true
  ): Double = {
    val discount = if (applyAgeDiscount) calculateDiscountBasedOnAge(amount, age) else 0
    amount - discount
  }

  private def calculateDiscountBasedOnAge(amount: Double, age: Int): Double = {
    age match {
      case young if young <= YoungMaximumAge => YoungDiscount * amount
      case old if old >= OldMinimumAge       => OldDiscount * amount
      case _                                 => 0
    }
  }
}
```

## [Extract variables](https://ythirion.github.io/refactoring-journey/journey/1-composing-method.html#extract-variable)

Shortcut : ⌘+⌥+V or Ctrl+Alt+V

- Open `Food` in `composing.methods` package
- Identify code smells

```scala
final case class Food(expirationDate: LocalDate, approvedForConsumption: Boolean, inspectorId: Option[Int]) {
  def isEdible: Boolean = {
    // Long expression -> can be simplified
    // expression isAfter : what does it mean in business terms ?
    // inspectorId not empty ?
    if (expirationDate.isAfter(LocalDate.now) && (approvedForConsumption == true) && inspectorId.isEmpty != true) true
    else false
  }
}
```

* Extract variables and simplify expression

```scala
case class Food(expirationDate: LocalDate,
                approvedForConsumption: Boolean,
                inspectorId: Option[Int]) {
  val hasBeenInspected: Boolean = inspectorId.isDefined

  def isFresh: Boolean = expirationDate.isAfter(LocalDate.now)
  
  def isEdible: Boolean =
    isFresh && approvedForConsumption && hasBeenInspected
}
```

## [Inline Temp](https://ythirion.github.io/refactoring-journey/journey/1-composing-method.html#inline-temp)
### Practice 1

- Open `OrderHelper` in `composing.methods` package
- Replace the price reference with the expression itself
  - In IntelliJ put your cursor on price and use Inline refactoring
  - ⌘+⌥+N or Ctrl+Alt+N

```scala
def deserveDiscount(order: Order): Boolean = {
  order.totalPrice > 1000
}
```

### Practice 2

- Refactor the `deserveDiscountBasedOnCustomer` by using previous learnings
- Remove Inline result : ⌘+⌥+N or Ctrl+Alt+N

```scala
def deserveDiscountBasedOnCustomer(order: Order): Boolean = {
  val nbOfProducts = order.products.size
  val customerAge = order.customer.age

  customerAge / nbOfProducts < 5
}
```

## [Remove Assignments to Parameters](https://ythirion.github.io/refactoring-journey/journey/1-composing-method.html#inline-temp)
- Open `OrderHelper` in `composing.methods` package
- Reflect on the method `calculateNewStock`
  - Which concept does it break ?
  - Command Query Separation : Stock => Int => Int

```scala
def calculateNewStock(stock: Stock, outFromStock: Int): Int = {
  // Update the number of Items in the stock passed in args
  stock.nbOfItems = stock.nbOfItems - outFromStock
  if (stock.nbOfItems < MINIMUM_ITEMS_IN_STOCK) return stock.nbOfItems + MINIMUM_ITEMS_IN_STOCK
  stock.nbOfItems
}
```

* Make this method pure
  * For the same input it will always produce the same output
  * Without side effects
* Make Stock Immutable

```scala
case class Stock(nbOfItems: Int)
```

* Refactor the function

```scala
def calculateNewStock(stock: Stock, outFromStock: Int): Int = {
  val newStock = stock.nbOfItems - outFromStock
  if (newStock < MINIMUM_ITEMS_IN_STOCK) newStock + MINIMUM_ITEMS_IN_STOCK else stock.nbOfItems
}
```

* Change the test that was asserting that we changed the stock state

```scala
class removeAssignmentsToParameters extends AnyFunSuite {
  test("Update stock") {
    val stock = Stock(5)
    val newStock = OrderHelper.calculateNewStock(stock, 3)
    // Stock stays untouched
    assert(stock.nbOfItems == 5)
    assert(newStock == 12)
  }
}
```

## [Replace long method with Method Object (composition)](https://ythirion.github.io/refactoring-journey/journey/1-composing-method.html#replace-long-method-with-method-object-composition)

* Open `Warehouse` in `composing.methods` package

- Extract the content of the `generateStockReport` method in a `StockReportGenerator` class

```scala
def generateStockReport: String = {
  val report: String = s"Report for warehouse : $id$lineSeparator"
  // Add detail
  val reportWithDetail = stock.foldLeft(report) { case (acc, (product, count)) =>
    acc + s"Product: ${product.name} Price: ${product.price} Stock : $count units$lineSeparator"
  }
  // Calculation of the Warehouse value logic should stay in the Warehouse (at least not in a report Generator)
  val reportWithDetailAndTotal = reportWithDetail + s"Total: ${stock.map { case (product, count) => product.price * count }.sum}€"
  reportWithDetailAndTotal
}
```

* Extract a new Method to calculate Stock value

```scala
lazy val calculateStockValue: Double =
  stock.map { case (product, count) => product.price * count }.sum
```

* Move report Generation logic in a `StockReportGenerator` object
  * Inject the Warehouse instance

```scala
object StockReportGenerator {
  def generate(warehouse: Warehouse): String = {
    val report: String = s"Report for warehouse : ${warehouse.id}$lineSeparator"
    // Add detail
    val reportWithDetail = warehouse.stock.foldLeft(report) { case (acc, (product, count)) =>
      acc + s"Product: ${product.name} Price: ${product.price} Stock : $count units$lineSeparator"
    }
    // Calculation of the Warehouse value logic should stay in the Warehouse (at least not in a report Generator)
    val reportWithDetailAndTotal = reportWithDetail + s"Total: ${warehouse.stock.map { case (product, count) => product.price * count }.sum}€"
    reportWithDetailAndTotal
  }
}
```

- What are the side effects on the consumers of the Warehouse class ?
  - Must inject a reportGenerator function or a Trait

```scala
final case class Warehouse(
                          id: Int,
                          stock: Map[Product, Integer]
                          ) {
  lazy val calculateStockValue: Double =
    stock.map { case (product, count) => product.price * count }.sum

  def generate(reportGenerator: Warehouse => String): String =
    reportGenerator(this)
}
```

* Tests are now broken
  * Plug them by using the `StockReportGenerator` object

```scala
class replaceMethodWithMethodObject extends AnyFunSuite {
  private val warehouse = Warehouse(
    9,
    Map(
      Product("Iphone 12", 989) -> 568,
      Product("Super Mario 3D World", 59.67) -> 98,
      Product("Blu Ray Avengers End Game", 28.99) -> 568,
      Product("Liverpool FC T-Shirt", 68) -> 78
    )
  )

  test("generate stock report") {
    assert(
      warehouse.generate(StockReportGenerator.generate) ==
              """Report for warehouse : 9
                |Product: Iphone 12 Price: 989.0 Stock : 568 units
                |Product: Super Mario 3D World Price: 59.67 Stock : 98 units
                |Product: Blu Ray Avengers End Game Price: 28.99 Stock : 568 units
                |Product: Liverpool FC T-Shirt Price: 68.0 Stock : 78 units
                |Total: 589369.98€""".stripMargin
    )
  }
}
```

* Refactor the `StockReportGenerator` object

```scala
object StockReportGenerator {
  def generate: Warehouse => String =
    (warehouse: Warehouse) => {
      createReport(warehouse) +
              formatStock(warehouse) +
              s"Total: ${warehouse.calculateStockValue}€"
    }

  private def createReport(warehouse: Warehouse): String =
    s"Report for warehouse : ${warehouse.id}$lineSeparator"

  private def formatStock(warehouse: Warehouse): String = {
    warehouse.stock.map {
      case (product, count) =>
        s"Product: ${product.name} Price: ${product.price} Stock : $count units$lineSeparator"
    }.mkString
  }
}
```

