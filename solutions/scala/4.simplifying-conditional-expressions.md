# 4. Simplifying Conditional Expressions
## [Consolidate conditional expressions](https://ythirion.github.io/refactoring-journey/journey/4-simplifying-conditional-expressions.html#consolidate-conditional-expression)

Shortcut : ⌘+⌥+M or Ctrl+Alt+M

* Open `AuthorizationService` in `simplifying.conditional.expressions` package
* Multiple conditionals that lead to the same result or action
* Before touching this kind of code with conditions
  * Always run your tests with coverage
  * By default IntelliJ `Code Coverage` is configured in Sampling
  * And tells us we have a 100% coverage

![image-20210805113416109](/img/solutions/coverage1.png)

* Edit configurations to pass in Tracing Mode
  * Tracing don't give use the same result and we can identify we have missing branches in our tests
  * >  Branches in yellow must be covered

![image-20210805113608827](/img/solutions/coverage2.png)

* Let's add missing test
  * When user if minor < 18

* Now we are covered, let's refactor

```scala
def isAuthorized(user: Option[User], action: Option[String]): Boolean = {
  // We first validate the action parameter
  if (action.exists(_.isEmpty)) return false
  // Then validate if we can authorize the User
  if (user.isEmpty) return false
  if (user.get.age < 18) return false
  if (user.get.isDisabled) return false
  if (!user.get.isLoyal) return false
  true
}
```

* Extract `isActionValid` function

```scala
def isActionValid(action: Option[String]) = action.exists(_.nonEmpty)
```

* Extract `canAuthorizeUser`

```scala
def canAuthorizeUser(user: Option[User]): Boolean = user.exists(u => u.age > Majority && !u.isDisabled && u.isLoyal)
```

* All together

```scala
class AuthorizationService {
  private val Majority = 18

  def isAuthorized(user: Option[User], action: Option[String]): Boolean = {
    isActionValid(action) && canAuthorizeUser(user)
  }

  def isActionValid(action: Option[String]) = action.exists(_.nonEmpty)

  def canAuthorizeUser(user: Option[User]): Boolean = user.exists(u => u.age > Majority && !u.isDisabled && u.isLoyal)
}
```

## [Consolidate duplicate conditional fragments](https://ythirion.github.io/refactoring-journey/journey/4-simplifying-conditional-expressions.html#consolidate-duplicate-conditional-fragments)
* Open `PriceCalculator` in `simplifying.conditional.expressions` package
* Identify code smells

```scala
object PriceCalculator {
  def calculatePrice(price: Double, isSaleDay: Boolean): Double = {
    // var is often evil
    var total = .0
    // Identical code in all branches -> notifySales(total)
    if (isSaleDay) {
      // magic stuff
      total = price * 0.5
      notifySales(total)
    } else {
      // magic stuff
      total = price * 0.98
      notifySales(total)
    }
    total
  }

  private def notifySales(amount: Double): Unit = {
    println(s"Notify sales $amount")
  }
}
```

* Extract the duplication outside from the branches

```scala
def calculatePrice(price: Double): Double = {
  var total = .0
  if (isSaleDay) {
    total = price * 0.5
  } else {
    total = price * 0.98
  }
  notifySales(total)
  total
}
```

* Extract constants

```scala
private val SaleDiscount = 0.5
private val NormalDayDiscount = 0.98
```

* Transform `var total` in `val total`

```scala
object PriceCalculator {
  private val SaleDiscount = 0.5
  private val NormalDayDiscount = 0.98

  def calculatePrice(price: Double, isSaleDay: Boolean): Double = {
    val total = price * discountRate(isSaleDay)
    notifySales(total)
    total
  }

  def discountRate(isSaleDay: Boolean): Double =
    if (isSaleDay) SaleDiscount else NormalDayDiscount

  private def notifySales(amount: Double): Unit = {
    println(s"Notify sales $amount")
  }
}
```

## [Decompose conditional](https://ythirion.github.io/refactoring-journey/journey/4-simplifying-conditional-expressions.html#decompose-conditional)

- Open `RoomPriceCalculator` in `simplifying.conditional.expressions` package
- Decompose conditional by extracting methods
- Which methods ?

```scala
class RoomPriceCalculator(
    clock: Clock,
    regularPrice: Double,
    highSeasonRate: Double,
    lowSeasonRate: Double,
    lowSeasonExtraCharge: Double
) {

  private val highSeasonStartDate = LocalDate.of(LocalDate.now.getYear, 6, 30)
  private val highSeasonEndDate = LocalDate.of(LocalDate.now.getYear, 10, 31)

  def calculatePriceFor(
      numberOfRooms: Int,
      selectedDate: LocalDate
  ): Option[Double] = {
    var price = .0

    if (
      selectedDate.isAfter(LocalDate.now(clock)) &&
      (selectedDate.isBefore(highSeasonStartDate) ||
      selectedDate.isAfter(highSeasonEndDate))
    ) {
      if (numberOfRooms <= 0) return None
      price =
        numberOfRooms * regularPrice * lowSeasonRate + lowSeasonExtraCharge
    } else if (selectedDate.isAfter(LocalDate.now(clock))) {
      price = numberOfRooms * regularPrice * highSeasonRate
      if (numberOfRooms <= 0) return None
    } else return None

    Some(price)
  }
}
```

* Extract `isLowSeason`

```scala
private def isLowSeason(selectedDate: LocalDate) =
  selectedDate.isBefore(highSeasonStartDate) || selectedDate.isAfter(highSeasonEndDate)
```

* Move `selectedDate.isAfter(today)` duplication and invert the guard

```scala
def calculatePriceFor(numberOfRooms: Int,
                      selectedDate: LocalDate): Option[Double] = {
  if (selectedDate.isBefore(today)) return None

  var price = .0

  if (isLowSeason(selectedDate)) {
    if (numberOfRooms <= 0) return None
    price = numberOfRooms * regularPrice * lowSeasonRate + lowSeasonExtraCharge
  }
  else {
    price = numberOfRooms * regularPrice * highSeasonRate
    if (numberOfRooms <= 0) return None
  }

  Some(price)
}
```

* Move `if (numberOfRooms <= 0) return None` duplication

```scala
def calculatePriceFor(numberOfRooms: Int,
                      selectedDate: LocalDate): Option[Double] = {
  if (selectedDate.isBefore(today)) return None
  if (numberOfRooms <= 0) return None
  
  var price = .0

  if (isLowSeason(selectedDate)) {
    price = numberOfRooms * regularPrice * lowSeasonRate + lowSeasonExtraCharge
  }
  else {
    price = numberOfRooms * regularPrice * highSeasonRate
  }

  Some(price)
}
```

* Clean a little by extracting inner functions

```scala
def calculatePriceFor(numberOfRooms: Int, selectedDate: LocalDate): Option[Double] = {
  def isLowSeason = selectedDate.isBefore(HighSeasonStartDate) || selectedDate.isAfter(HighSeasonEndDate)
  def lowSeasonPrice: Double = numberOfRooms * regularPrice * lowSeasonRate + lowSeasonExtraCharge
  def highSeasonPrice: Double = numberOfRooms * regularPrice * highSeasonRate

  if (selectedDate.isBefore(LocalDate.now(clock)) || numberOfRooms <= 0) None
  else Some(if (isLowSeason) lowSeasonPrice else highSeasonPrice)
}
```

* Still a little of duplication here ?
  * `numberOfRooms * regularPrice` repeated twice
  * Create a higher order function to calculate the price

```scala
def calculatePriceFor(numberOfRooms: Int, selectedDate: LocalDate): Option[Double] = {
  def isLowSeason = selectedDate.isBefore(HighSeasonStartDate) || selectedDate.isAfter(HighSeasonEndDate)
  def calculatePrice(seasonPrice: Double => Double): Double = seasonPrice(numberOfRooms * regularPrice)
  def lowSeasonPrice: Double = calculatePrice(x => x * lowSeasonRate + lowSeasonExtraCharge)
  def highSeasonPrice: Double = calculatePrice(x => x * highSeasonRate)

  if (selectedDate.isBefore(LocalDate.now(clock)) || numberOfRooms <= 0) None
  else Some(if (isLowSeason) lowSeasonPrice else highSeasonPrice)
}
```

## [Replace Conditional with Polymorphism](https://ythirion.github.io/refactoring-journey/journey/4-simplifying-conditional-expressions.html#replace-conditional-with-polymorphism)

- Open `Calculator` in `simplifying.conditional.expressions` package
- Code smells

```scala
object Calculator {
  // Function signature is not explicit (can throw an exception)
  def calculate(a: Int, b: Int, operator: String): Int = {
    // var is hell
    var result = 0
    // Not very open for extension
    // What happens if I want to add a new operator ?
    // If those checks are made several times it can lead to a lot of errors / mistakes
    if ("add" == operator) result = a + b
    // Magic string everywhere
    else if ("multiply" == operator) result = a * b
    else if ("divide" == operator) result = a / b
    else if ("subtract" == operator) result = a - b
    else throw new IllegalArgumentException("Not supported operator")
    result
  }
}
```

### Option 1 : Use Trait and classes

* Create a trait `Operator`

```scala
trait Operator {
  def calculate(a: Int, b: Int): Int
}
```

* Create case objects for each operation

```scala
case object Add extends Operator {
  override def calculate(a: Int, b: Int): Int = a + b
}

case object Multiply extends Operator {
  override def calculate(a: Int, b: Int): Int = a * b
}

case object Divide extends Operator {
  override def calculate(a: Int, b: Int): Int = a / b
}

case object Subtract extends Operator {
  override def calculate(a: Int, b: Int): Int = a - b
}
```

* Put magic String in constants

```scala
val add = "add"
val multiply = "multiply"
val divide = "divide"
val subtract = "subtract"
```

* Create a map representing supported operations

```scala
private val supportedOperators = Map[String, Operator](
  add -> Add,
  multiply -> Multiply,
  divide -> Divide,
  subtract -> Subtract
)
```

* Refactor the calculate function to use the map
  * The funcion is now `Open for extension and closed for modification`

```scala
def calculate(a: Int, b: Int, operator: String): Int = {
  supportedOperators.get(operator) match {
    case Some(op) => op.calculate(a, b)
    case None => throw new IllegalArgumentException("Not supported operator")
  }
}
```

* Change the function signature to represent the failure state to the outside world
  * Have an impact on clients from this object

```scala
def calculate(a: Int, b: Int, operator: String): Try[Int] = {
  supportedOperators.get(operator) match {
    case Some(op) => Success(op.calculate(a, b))
    case None => Failure(new IllegalArgumentException("Not supported operator"))
  }
}
```

* Finish by refactoring the tests

```scala
package org.ythirion.refactoring.journey
package simplifying.conditional.expressions

import org.scalatest.TryValues.convertTryToSuccessOrFailure
import org.scalatest.funsuite.AnyFunSuite

class replaceConditionalWithPolymorphism extends AnyFunSuite {
  test("calculator should support add") {
    assert(Calculator.calculate(1, 2, Calculator.add).success.value == 3)
  }

  test("calculator should support multiply") {
    assert(Calculator.calculate(90, 4, Calculator.multiply).success.value == 360)
  }

  test("calculator should support divide") {
    assert(Calculator.calculate(84, 4, Calculator.divide).success.value == 21)
  }

  test("calculator should support subtract") {
    assert(Calculator.calculate(84, 23, Calculator.subtract).success.value == 61)
  }

  test("calculator should throw exception on unsupported operator") {
    assert(Calculator.calculate(84, 23, "unsupported operator")
      .failure.exception.getMessage == "Not supported operator")
  }
}
```

### Option 2 : Only function registration

* Create a map to register the operation function

```scala
private val supportedOperators = Map[String, (Int, Int) => Int](
  add -> { (a, b) => a + b },
  multiply -> { (a, b) => a * b },
  divide -> { (a, b) => a / b },
  subtract -> { (a, b) => a - b },
)
```

* The rest remains the same

```scala
def calculate(a: Int, b: Int, operator: String): Try[Int] = {
  supportedOperators.get(operator) match {
    case Some(op) => Success(op(a, b))
    case None => Failure(new IllegalArgumentException("Not supported operator"))
  }
}
```

